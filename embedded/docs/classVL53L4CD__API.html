<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>btb: VL53L4CD_API Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">btb
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classVL53L4CD__API-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">VL53L4CD_API Class Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2e522cd6d66becb6315fb2fa50a00055"><td class="memItemLeft" align="right" valign="top">VL53L4CD_Error&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVL53L4CD__API.html#a2e522cd6d66becb6315fb2fa50a00055">VL53L4CD_GetSWVersion</a> (<a class="el" href="structVL53L4CD__Version__t.html">VL53L4CD_Version_t</a> *pVersion)</td></tr>
<tr class="memdesc:a2e522cd6d66becb6315fb2fa50a00055"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function programs the software driver version.  <a href="classVL53L4CD__API.html#a2e522cd6d66becb6315fb2fa50a00055">More...</a><br /></td></tr>
<tr class="separator:a2e522cd6d66becb6315fb2fa50a00055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87523f5f80914c5712bbb2d9714b6267"><td class="memItemLeft" align="right" valign="top">VL53L4CD_Error&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVL53L4CD__API.html#a87523f5f80914c5712bbb2d9714b6267">VL53L4CD_SetI2CAddress</a> (<a class="el" href="structVL53L4CD__LinuxDev.html">Dev_t</a> dev, uint8_t new_address)</td></tr>
<tr class="memdesc:a87523f5f80914c5712bbb2d9714b6267"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets a new I2C address to a sensor. It can be used for example when multiple sensors share the same I2C bus.  <a href="classVL53L4CD__API.html#a87523f5f80914c5712bbb2d9714b6267">More...</a><br /></td></tr>
<tr class="separator:a87523f5f80914c5712bbb2d9714b6267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39750d4a46e02e81b5ae0e739def7ed0"><td class="memItemLeft" align="right" valign="top">VL53L4CD_Error&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVL53L4CD__API.html#a39750d4a46e02e81b5ae0e739def7ed0">VL53L4CD_GetSensorId</a> (<a class="el" href="structVL53L4CD__LinuxDev.html">Dev_t</a> dev, uint16_t *p_id)</td></tr>
<tr class="memdesc:a39750d4a46e02e81b5ae0e739def7ed0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to get the sensor id of <a class="el" href="classVL53L4CD.html">VL53L4CD</a>. The sensor id should be 0xEBAA.  <a href="classVL53L4CD__API.html#a39750d4a46e02e81b5ae0e739def7ed0">More...</a><br /></td></tr>
<tr class="separator:a39750d4a46e02e81b5ae0e739def7ed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad04915d4dc676f2306874b75a670c091"><td class="memItemLeft" align="right" valign="top">VL53L4CD_Error&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVL53L4CD__API.html#ad04915d4dc676f2306874b75a670c091">VL53L4CD_SensorInit</a> (<a class="el" href="structVL53L4CD__LinuxDev.html">Dev_t</a> dev)</td></tr>
<tr class="memdesc:ad04915d4dc676f2306874b75a670c091"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to initialize the sensor.  <a href="classVL53L4CD__API.html#ad04915d4dc676f2306874b75a670c091">More...</a><br /></td></tr>
<tr class="separator:ad04915d4dc676f2306874b75a670c091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0779f406671b37fc75b34c20d6c56eee"><td class="memItemLeft" align="right" valign="top">VL53L4CD_Error&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVL53L4CD__API.html#a0779f406671b37fc75b34c20d6c56eee">VL53L4CD_ClearInterrupt</a> (<a class="el" href="structVL53L4CD__LinuxDev.html">Dev_t</a> dev)</td></tr>
<tr class="memdesc:a0779f406671b37fc75b34c20d6c56eee"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function clears the interrupt. It needs to be called after a ranging data reading to arm the interrupt for the next data ready event.  <a href="classVL53L4CD__API.html#a0779f406671b37fc75b34c20d6c56eee">More...</a><br /></td></tr>
<tr class="separator:a0779f406671b37fc75b34c20d6c56eee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3013012a08e2592d13653a267806c98c"><td class="memItemLeft" align="right" valign="top">VL53L4CD_Error&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVL53L4CD__API.html#a3013012a08e2592d13653a267806c98c">VL53L4CD_StartRanging</a> (<a class="el" href="structVL53L4CD__LinuxDev.html">Dev_t</a> dev)</td></tr>
<tr class="memdesc:a3013012a08e2592d13653a267806c98c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function starts a ranging session. The ranging operation is continuous. The clear interrupt has to be done after each get data to allow the interrupt to raise when the next data is ready.  <a href="classVL53L4CD__API.html#a3013012a08e2592d13653a267806c98c">More...</a><br /></td></tr>
<tr class="separator:a3013012a08e2592d13653a267806c98c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a491af0b13c9fa2c9e3197b80c2f50f8b"><td class="memItemLeft" align="right" valign="top">VL53L4CD_Error&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVL53L4CD__API.html#a491af0b13c9fa2c9e3197b80c2f50f8b">VL53L4CD_StopRanging</a> (<a class="el" href="structVL53L4CD__LinuxDev.html">Dev_t</a> dev)</td></tr>
<tr class="memdesc:a491af0b13c9fa2c9e3197b80c2f50f8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function stops the ranging in progress.  <a href="classVL53L4CD__API.html#a491af0b13c9fa2c9e3197b80c2f50f8b">More...</a><br /></td></tr>
<tr class="separator:a491af0b13c9fa2c9e3197b80c2f50f8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbcb7208dd993b4c03b1bed873af975d"><td class="memItemLeft" align="right" valign="top">VL53L4CD_Error&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVL53L4CD__API.html#adbcb7208dd993b4c03b1bed873af975d">VL53L4CD_CheckForDataReady</a> (<a class="el" href="structVL53L4CD__LinuxDev.html">Dev_t</a> dev, uint8_t *p_is_data_ready)</td></tr>
<tr class="memdesc:adbcb7208dd993b4c03b1bed873af975d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function check if a new data is available by polling a dedicated register.  <a href="classVL53L4CD__API.html#adbcb7208dd993b4c03b1bed873af975d">More...</a><br /></td></tr>
<tr class="separator:adbcb7208dd993b4c03b1bed873af975d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2585a3f22fdf2b0ee32820ec42da3961"><td class="memItemLeft" align="right" valign="top">VL53L4CD_Error&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVL53L4CD__API.html#a2585a3f22fdf2b0ee32820ec42da3961">VL53L4CD_SetRangeTiming</a> (<a class="el" href="structVL53L4CD__LinuxDev.html">Dev_t</a> dev, uint32_t timing_budget_ms, uint32_t inter_measurement_ms)</td></tr>
<tr class="memdesc:a2585a3f22fdf2b0ee32820ec42da3961"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets new range timing. Timing are composed of TimingBudget and InterMeasurement. TimingBudget represents the timing during VCSEL enabled, and InterMeasurement the time between two measurements. The sensor can have different ranging mode depending of the configuration, please refer to the user manual for more information.  <a href="classVL53L4CD__API.html#a2585a3f22fdf2b0ee32820ec42da3961">More...</a><br /></td></tr>
<tr class="separator:a2585a3f22fdf2b0ee32820ec42da3961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25f7a067fae122c18757c4197502de66"><td class="memItemLeft" align="right" valign="top">VL53L4CD_Error&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVL53L4CD__API.html#a25f7a067fae122c18757c4197502de66">VL53L4CD_GetRangeTiming</a> (<a class="el" href="structVL53L4CD__LinuxDev.html">Dev_t</a> dev, uint32_t *p_timing_budget_ms, uint32_t *p_inter_measurement_ms)</td></tr>
<tr class="memdesc:a25f7a067fae122c18757c4197502de66"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the current range timing. Timing are composed of TimingBudget and InterMeasurement. TimingBudget represents the timing during VCSEL enabled, and InterMeasurement the time between two measurements. The sensor can have different ranging mode depending of the configuration, please refer to the user manual for more information.  <a href="classVL53L4CD__API.html#a25f7a067fae122c18757c4197502de66">More...</a><br /></td></tr>
<tr class="separator:a25f7a067fae122c18757c4197502de66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af19795ff7d4e1b8f3153ab2e033302e7"><td class="memItemLeft" align="right" valign="top">VL53L4CD_Error&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVL53L4CD__API.html#af19795ff7d4e1b8f3153ab2e033302e7">VL53L4CD_GetResult</a> (<a class="el" href="structVL53L4CD__LinuxDev.html">Dev_t</a> dev, <a class="el" href="structVL53L4CD__ResultsData__t.html">VL53L4CD_ResultsData_t</a> *pResult)</td></tr>
<tr class="memdesc:af19795ff7d4e1b8f3153ab2e033302e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the results reported by the sensor.  <a href="classVL53L4CD__API.html#af19795ff7d4e1b8f3153ab2e033302e7">More...</a><br /></td></tr>
<tr class="separator:af19795ff7d4e1b8f3153ab2e033302e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cd4dc976d343d0cff8696ea60a1068d"><td class="memItemLeft" align="right" valign="top">VL53L4CD_Error&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVL53L4CD__API.html#a4cd4dc976d343d0cff8696ea60a1068d">VL53L4CD_SetOffset</a> (<a class="el" href="structVL53L4CD__LinuxDev.html">Dev_t</a> dev, int16_t OffsetValueInMm)</td></tr>
<tr class="memdesc:a4cd4dc976d343d0cff8696ea60a1068d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets a new offset correction in mm. Offset corresponds to the difference in millimeters between real distance and measured distance.  <a href="classVL53L4CD__API.html#a4cd4dc976d343d0cff8696ea60a1068d">More...</a><br /></td></tr>
<tr class="separator:a4cd4dc976d343d0cff8696ea60a1068d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aa27650d85f31b269426710fb8ebc93"><td class="memItemLeft" align="right" valign="top">VL53L4CD_Error&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVL53L4CD__API.html#a5aa27650d85f31b269426710fb8ebc93">VL53L4CD_GetOffset</a> (<a class="el" href="structVL53L4CD__LinuxDev.html">Dev_t</a> dev, int16_t *Offset)</td></tr>
<tr class="memdesc:a5aa27650d85f31b269426710fb8ebc93"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the current offset correction in mm. Offset corresponds to the difference in millimeters between real distance and measured distance.  <a href="classVL53L4CD__API.html#a5aa27650d85f31b269426710fb8ebc93">More...</a><br /></td></tr>
<tr class="separator:a5aa27650d85f31b269426710fb8ebc93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e02c0ae9a798c8972e84cb22b3c4a06"><td class="memItemLeft" align="right" valign="top">VL53L4CD_Error&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVL53L4CD__API.html#a1e02c0ae9a798c8972e84cb22b3c4a06">VL53L4CD_SetXtalk</a> (<a class="el" href="structVL53L4CD__LinuxDev.html">Dev_t</a> dev, uint16_t XtalkValueKcps)</td></tr>
<tr class="memdesc:a1e02c0ae9a798c8972e84cb22b3c4a06"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets a new Xtalk value in kcps. Xtalk represents the correction to apply to the sensor when a protective coverglass is placed at the top of the sensor.  <a href="classVL53L4CD__API.html#a1e02c0ae9a798c8972e84cb22b3c4a06">More...</a><br /></td></tr>
<tr class="separator:a1e02c0ae9a798c8972e84cb22b3c4a06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a42e28fc1e58cc1708d3a9b49563f03"><td class="memItemLeft" align="right" valign="top">VL53L4CD_Error&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVL53L4CD__API.html#a0a42e28fc1e58cc1708d3a9b49563f03">VL53L4CD_GetXtalk</a> (<a class="el" href="structVL53L4CD__LinuxDev.html">Dev_t</a> dev, uint16_t *p_xtalk_kcps)</td></tr>
<tr class="memdesc:a0a42e28fc1e58cc1708d3a9b49563f03"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the current Xtalk value in kcps. Xtalk represents the correction to apply to the sensor when a protective coverglass is placed at the top of the sensor.  <a href="classVL53L4CD__API.html#a0a42e28fc1e58cc1708d3a9b49563f03">More...</a><br /></td></tr>
<tr class="separator:a0a42e28fc1e58cc1708d3a9b49563f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d9a651e5194e5daa081085c6691642f"><td class="memItemLeft" align="right" valign="top">VL53L4CD_Error&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVL53L4CD__API.html#a4d9a651e5194e5daa081085c6691642f">VL53L4CD_SetDetectionThresholds</a> (<a class="el" href="structVL53L4CD__LinuxDev.html">Dev_t</a> dev, uint16_t distance_low_mm, uint16_t distance_high_mm, uint8_t window)</td></tr>
<tr class="memdesc:a4d9a651e5194e5daa081085c6691642f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets new detection thresholds. The detection thresholds can be programmed to generate an interrupt on pin 7 (GPIO1), only when a condition on distance is reach. Example: VL53L4CD_SetDistanceThreshold(dev,100,300,0): Below 100 mm VL53L4CD_SetDistanceThreshold(dev,100,300,1): Above 300 mm VL53L4CD_SetDistanceThreshold(dev,100,300,2): Below 100mm or above 300mm VL53L4CD_SetDistanceThreshold(dev,100,300,3): Above 100mm or below 300mm.  <a href="classVL53L4CD__API.html#a4d9a651e5194e5daa081085c6691642f">More...</a><br /></td></tr>
<tr class="separator:a4d9a651e5194e5daa081085c6691642f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc880b2d4e70fa6ba50822740a0802bc"><td class="memItemLeft" align="right" valign="top">VL53L4CD_Error&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVL53L4CD__API.html#adc880b2d4e70fa6ba50822740a0802bc">VL53L4CD_GetDetectionThresholds</a> (<a class="el" href="structVL53L4CD__LinuxDev.html">Dev_t</a> dev, uint16_t *p_distance_low_mm, uint16_t *p_distance_high_mm, uint8_t *p_window)</td></tr>
<tr class="memdesc:adc880b2d4e70fa6ba50822740a0802bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the current detection thresholds. The detection thresholds can be programmed to generate an interrupt on pin 7 (GPIO1), only when a condition on distance is reach.  <a href="classVL53L4CD__API.html#adc880b2d4e70fa6ba50822740a0802bc">More...</a><br /></td></tr>
<tr class="separator:adc880b2d4e70fa6ba50822740a0802bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a115c3de908fb7b9dbfcf91bdac6a551c"><td class="memItemLeft" align="right" valign="top">VL53L4CD_Error&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVL53L4CD__API.html#a115c3de908fb7b9dbfcf91bdac6a551c">VL53L4CD_SetSignalThreshold</a> (<a class="el" href="structVL53L4CD__LinuxDev.html">Dev_t</a> dev, uint16_t signal_kcps)</td></tr>
<tr class="memdesc:a115c3de908fb7b9dbfcf91bdac6a551c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets a new signal threshold in kcps. If a target has a lower signal as the programmed value, the result status in structure '<a class="el" href="structVL53L4CD__ResultsData__t.html" title="Packed reading results type.">VL53L4CD_ResultsData_t</a>' will be equal to 2.  <a href="classVL53L4CD__API.html#a115c3de908fb7b9dbfcf91bdac6a551c">More...</a><br /></td></tr>
<tr class="separator:a115c3de908fb7b9dbfcf91bdac6a551c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade677c4e4e63c12b1b34fca50180f7a0"><td class="memItemLeft" align="right" valign="top">VL53L4CD_Error&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVL53L4CD__API.html#ade677c4e4e63c12b1b34fca50180f7a0">VL53L4CD_GetSignalThreshold</a> (<a class="el" href="structVL53L4CD__LinuxDev.html">Dev_t</a> dev, uint16_t *p_signal_kcps)</td></tr>
<tr class="memdesc:ade677c4e4e63c12b1b34fca50180f7a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the current signal threshold in kcps. If a target has a lower signal as the programmed value, the result status in structure '<a class="el" href="structVL53L4CD__ResultsData__t.html" title="Packed reading results type.">VL53L4CD_ResultsData_t</a>' will be equal to 2.  <a href="classVL53L4CD__API.html#ade677c4e4e63c12b1b34fca50180f7a0">More...</a><br /></td></tr>
<tr class="separator:ade677c4e4e63c12b1b34fca50180f7a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada4fb4ff20dacbed66e6c5261e4ff813"><td class="memItemLeft" align="right" valign="top">VL53L4CD_Error&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVL53L4CD__API.html#ada4fb4ff20dacbed66e6c5261e4ff813">VL53L4CD_SetSigmaThreshold</a> (<a class="el" href="structVL53L4CD__LinuxDev.html">Dev_t</a> dev, uint16_t sigma_mm)</td></tr>
<tr class="memdesc:ada4fb4ff20dacbed66e6c5261e4ff813"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function programs a new sigma threshold. The sigma corresponds to the standard deviation of the returned pulse. If the computed sigma is above the programmed value, the result status in structure '<a class="el" href="structVL53L4CD__ResultsData__t.html" title="Packed reading results type.">VL53L4CD_ResultsData_t</a>' will be equal to 1.  <a href="classVL53L4CD__API.html#ada4fb4ff20dacbed66e6c5261e4ff813">More...</a><br /></td></tr>
<tr class="separator:ada4fb4ff20dacbed66e6c5261e4ff813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a443fc7e50040da91572b1371f6d23fe1"><td class="memItemLeft" align="right" valign="top">VL53L4CD_Error&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVL53L4CD__API.html#a443fc7e50040da91572b1371f6d23fe1">VL53L4CD_GetSigmaThreshold</a> (<a class="el" href="structVL53L4CD__LinuxDev.html">Dev_t</a> dev, uint16_t *p_sigma_mm)</td></tr>
<tr class="memdesc:a443fc7e50040da91572b1371f6d23fe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the current sigma threshold. The sigma corresponds to the standard deviation of the returned pulse. If the computed sigma is above the programmed value, the result status in structure '<a class="el" href="structVL53L4CD__ResultsData__t.html" title="Packed reading results type.">VL53L4CD_ResultsData_t</a>' will be equal to 1.  <a href="classVL53L4CD__API.html#a443fc7e50040da91572b1371f6d23fe1">More...</a><br /></td></tr>
<tr class="separator:a443fc7e50040da91572b1371f6d23fe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9c83b64bcfbb37376b0694c64745564"><td class="memItemLeft" align="right" valign="top">VL53L4CD_Error&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVL53L4CD__API.html#aa9c83b64bcfbb37376b0694c64745564">VL53L4CD_StartTemperatureUpdate</a> (<a class="el" href="structVL53L4CD__LinuxDev.html">Dev_t</a> dev)</td></tr>
<tr class="memdesc:aa9c83b64bcfbb37376b0694c64745564"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function can be called when the temperature might have changed by more than 8 degrees Celsius. The function can only be used if the sensor is not ranging, otherwise, the ranging needs to be stopped using function '<a class="el" href="classVL53L4CD__API.html#a491af0b13c9fa2c9e3197b80c2f50f8b" title="This function stops the ranging in progress.">VL53L4CD_StopRanging()</a>'. After calling this function, the ranging can restart normally.  <a href="classVL53L4CD__API.html#aa9c83b64bcfbb37376b0694c64745564">More...</a><br /></td></tr>
<tr class="separator:aa9c83b64bcfbb37376b0694c64745564"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="adbcb7208dd993b4c03b1bed873af975d" name="adbcb7208dd993b4c03b1bed873af975d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbcb7208dd993b4c03b1bed873af975d">&#9670;&nbsp;</a></span>VL53L4CD_CheckForDataReady()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VL53L4CD_Error VL53L4CD_API::VL53L4CD_CheckForDataReady </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVL53L4CD__LinuxDev.html">Dev_t</a>&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>p_is_data_ready</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function check if a new data is available by polling a dedicated register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(Dev_t)</td><td>dev : instance of selected <a class="el" href="classVL53L4CD.html">VL53L4CD</a> sensor. </td></tr>
    <tr><td class="paramname">(uint8_t)</td><td>*p_is_data_ready : Pointer containing a flag to know if a data is ready : 0 = no data ready, 1 = data ready. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(VL53L4CD_ERROR) status : 0 if OK. </dd></dl>

</div>
</div>
<a id="a0779f406671b37fc75b34c20d6c56eee" name="a0779f406671b37fc75b34c20d6c56eee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0779f406671b37fc75b34c20d6c56eee">&#9670;&nbsp;</a></span>VL53L4CD_ClearInterrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VL53L4CD_Error VL53L4CD_API::VL53L4CD_ClearInterrupt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVL53L4CD__LinuxDev.html">Dev_t</a>&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function clears the interrupt. It needs to be called after a ranging data reading to arm the interrupt for the next data ready event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(Dev_t)</td><td>dev : Device instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(VL53L4CD_ERROR) status : 0 if OK. </dd></dl>

</div>
</div>
<a id="adc880b2d4e70fa6ba50822740a0802bc" name="adc880b2d4e70fa6ba50822740a0802bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc880b2d4e70fa6ba50822740a0802bc">&#9670;&nbsp;</a></span>VL53L4CD_GetDetectionThresholds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VL53L4CD_Error VL53L4CD_API::VL53L4CD_GetDetectionThresholds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVL53L4CD__LinuxDev.html">Dev_t</a>&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>p_distance_low_mm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>p_distance_high_mm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>p_window</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the current detection thresholds. The detection thresholds can be programmed to generate an interrupt on pin 7 (GPIO1), only when a condition on distance is reach. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(Dev_t)</td><td>dev : instance of selected <a class="el" href="classVL53L4CD.html">VL53L4CD</a> sensor. </td></tr>
    <tr><td class="paramname">(uint16_t)</td><td>*p_distance_low_mm : Pointer of low distance threshold in millimeters. </td></tr>
    <tr><td class="paramname">(uint16_t)</td><td>*p_distance_high_mm : Pointer of high distance threshold in millimeters. </td></tr>
    <tr><td class="paramname">(uint8_t)</td><td>*p_window : Interrupt windows (0=below low threshold; 1=above high threshold; 2=out of low/high windows; 3=in low/high windows) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(VL53L4CD_ERROR) status : 0 if OK. </dd></dl>

</div>
</div>
<a id="a5aa27650d85f31b269426710fb8ebc93" name="a5aa27650d85f31b269426710fb8ebc93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aa27650d85f31b269426710fb8ebc93">&#9670;&nbsp;</a></span>VL53L4CD_GetOffset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VL53L4CD_Error VL53L4CD_API::VL53L4CD_GetOffset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVL53L4CD__LinuxDev.html">Dev_t</a>&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t *&#160;</td>
          <td class="paramname"><em>Offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the current offset correction in mm. Offset corresponds to the difference in millimeters between real distance and measured distance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(Dev_t)</td><td>dev : instance of selected <a class="el" href="classVL53L4CD.html">VL53L4CD</a> sensor. </td></tr>
    <tr><td class="paramname">(int16_t)</td><td>OffsetValueInMm : Offset value in millimeters. The minimum value is -1024mm and maximum is 1023mm. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(uint8_t) status : 0 if OK. </dd></dl>

</div>
</div>
<a id="a25f7a067fae122c18757c4197502de66" name="a25f7a067fae122c18757c4197502de66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25f7a067fae122c18757c4197502de66">&#9670;&nbsp;</a></span>VL53L4CD_GetRangeTiming()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VL53L4CD_Error VL53L4CD_API::VL53L4CD_GetRangeTiming </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVL53L4CD__LinuxDev.html">Dev_t</a>&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>p_timing_budget_ms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>p_inter_measurement_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the current range timing. Timing are composed of TimingBudget and InterMeasurement. TimingBudget represents the timing during VCSEL enabled, and InterMeasurement the time between two measurements. The sensor can have different ranging mode depending of the configuration, please refer to the user manual for more information. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(Dev_t)</td><td>dev : instance of selected <a class="el" href="classVL53L4CD.html">VL53L4CD</a> sensor. </td></tr>
    <tr><td class="paramname">(uint32_t)</td><td>*p_timing_budget_ms : Pointer containing the current timing budget in ms. </td></tr>
    <tr><td class="paramname">(uint32_t)</td><td>*p_inter_measurement_ms : Pointer containing the current inter-measurement in ms. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(uint8_t) status : 0 if OK. </dd></dl>

</div>
</div>
<a id="af19795ff7d4e1b8f3153ab2e033302e7" name="af19795ff7d4e1b8f3153ab2e033302e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af19795ff7d4e1b8f3153ab2e033302e7">&#9670;&nbsp;</a></span>VL53L4CD_GetResult()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VL53L4CD_Error VL53L4CD_API::VL53L4CD_GetResult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVL53L4CD__LinuxDev.html">Dev_t</a>&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structVL53L4CD__ResultsData__t.html">VL53L4CD_ResultsData_t</a> *&#160;</td>
          <td class="paramname"><em>pResult</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the results reported by the sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(Dev_t)</td><td>dev : instance of selected <a class="el" href="classVL53L4CD.html">VL53L4CD</a> sensor. </td></tr>
    <tr><td class="paramname">(VL53L4CD_ResultsData_t)</td><td>*pResult : Pointer of structure, filled with the ranging results. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(uint8_t) status : 0 if OK. </dd></dl>

</div>
</div>
<a id="a39750d4a46e02e81b5ae0e739def7ed0" name="a39750d4a46e02e81b5ae0e739def7ed0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39750d4a46e02e81b5ae0e739def7ed0">&#9670;&nbsp;</a></span>VL53L4CD_GetSensorId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VL53L4CD_Error VL53L4CD_API::VL53L4CD_GetSensorId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVL53L4CD__LinuxDev.html">Dev_t</a>&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>p_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to get the sensor id of <a class="el" href="classVL53L4CD.html">VL53L4CD</a>. The sensor id should be 0xEBAA. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(Dev_t)</td><td>dev : Device instance. </td></tr>
    <tr><td class="paramname">(uint16_t)</td><td>*p_id : Sensor id. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(VL53L4CD_ERROR) status : 0 if OK. </dd></dl>

</div>
</div>
<a id="a443fc7e50040da91572b1371f6d23fe1" name="a443fc7e50040da91572b1371f6d23fe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a443fc7e50040da91572b1371f6d23fe1">&#9670;&nbsp;</a></span>VL53L4CD_GetSigmaThreshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VL53L4CD_Error VL53L4CD_API::VL53L4CD_GetSigmaThreshold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVL53L4CD__LinuxDev.html">Dev_t</a>&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>p_sigma_mm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the current sigma threshold. The sigma corresponds to the standard deviation of the returned pulse. If the computed sigma is above the programmed value, the result status in structure '<a class="el" href="structVL53L4CD__ResultsData__t.html" title="Packed reading results type.">VL53L4CD_ResultsData_t</a>' will be equal to 1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(Dev_t)</td><td>dev : instance of selected <a class="el" href="classVL53L4CD.html">VL53L4CD</a> sensor. </td></tr>
    <tr><td class="paramname">(uint16_t)</td><td>*p_sigma_mm : Current sigma threshold in mm. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(VL53L4CD_ERROR) status : 0 if programming is OK. </dd></dl>

</div>
</div>
<a id="ade677c4e4e63c12b1b34fca50180f7a0" name="ade677c4e4e63c12b1b34fca50180f7a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade677c4e4e63c12b1b34fca50180f7a0">&#9670;&nbsp;</a></span>VL53L4CD_GetSignalThreshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VL53L4CD_Error VL53L4CD_API::VL53L4CD_GetSignalThreshold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVL53L4CD__LinuxDev.html">Dev_t</a>&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>p_signal_kcps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the current signal threshold in kcps. If a target has a lower signal as the programmed value, the result status in structure '<a class="el" href="structVL53L4CD__ResultsData__t.html" title="Packed reading results type.">VL53L4CD_ResultsData_t</a>' will be equal to 2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(Dev_t)</td><td>dev : instance of selected <a class="el" href="classVL53L4CD.html">VL53L4CD</a> sensor. </td></tr>
    <tr><td class="paramname">(uint16_t)</td><td>*p_signal_kcps : Pointer of signal threshold in kcps. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(VL53L4CD_ERROR) status : 0 if OK. </dd></dl>

</div>
</div>
<a id="a2e522cd6d66becb6315fb2fa50a00055" name="a2e522cd6d66becb6315fb2fa50a00055"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e522cd6d66becb6315fb2fa50a00055">&#9670;&nbsp;</a></span>VL53L4CD_GetSWVersion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VL53L4CD_Error VL53L4CD_API::VL53L4CD_GetSWVersion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVL53L4CD__Version__t.html">VL53L4CD_Version_t</a> *&#160;</td>
          <td class="paramname"><em>pVersion</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function programs the software driver version. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(VL53L4CD_Version_t)</td><td>pVersion : Pointer of structure, containing the software version. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(VL53L4CD_ERROR) status : 0 if SW version is OK. </dd></dl>

</div>
</div>
<a id="a0a42e28fc1e58cc1708d3a9b49563f03" name="a0a42e28fc1e58cc1708d3a9b49563f03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a42e28fc1e58cc1708d3a9b49563f03">&#9670;&nbsp;</a></span>VL53L4CD_GetXtalk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VL53L4CD_Error VL53L4CD_API::VL53L4CD_GetXtalk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVL53L4CD__LinuxDev.html">Dev_t</a>&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>p_xtalk_kcps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the current Xtalk value in kcps. Xtalk represents the correction to apply to the sensor when a protective coverglass is placed at the top of the sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(Dev_t)</td><td>dev : instance of selected <a class="el" href="classVL53L4CD.html">VL53L4CD</a> sensor. </td></tr>
    <tr><td class="paramname">(uint16_t)</td><td>p_xtalk_kcps : Pointer of current xtalk value in kcps. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(VL53L4CD_ERROR) status : 0 if OK. </dd></dl>

</div>
</div>
<a id="ad04915d4dc676f2306874b75a670c091" name="ad04915d4dc676f2306874b75a670c091"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad04915d4dc676f2306874b75a670c091">&#9670;&nbsp;</a></span>VL53L4CD_SensorInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VL53L4CD_Error VL53L4CD_API::VL53L4CD_SensorInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVL53L4CD__LinuxDev.html">Dev_t</a>&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to initialize the sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(Dev_t)</td><td>dev : Device instance to initialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(VL53L4CD_ERROR) status : 0 if init is OK. </dd></dl>

</div>
</div>
<a id="a4d9a651e5194e5daa081085c6691642f" name="a4d9a651e5194e5daa081085c6691642f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d9a651e5194e5daa081085c6691642f">&#9670;&nbsp;</a></span>VL53L4CD_SetDetectionThresholds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VL53L4CD_Error VL53L4CD_API::VL53L4CD_SetDetectionThresholds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVL53L4CD__LinuxDev.html">Dev_t</a>&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>distance_low_mm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>distance_high_mm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>window</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets new detection thresholds. The detection thresholds can be programmed to generate an interrupt on pin 7 (GPIO1), only when a condition on distance is reach. Example: VL53L4CD_SetDistanceThreshold(dev,100,300,0): Below 100 mm VL53L4CD_SetDistanceThreshold(dev,100,300,1): Above 300 mm VL53L4CD_SetDistanceThreshold(dev,100,300,2): Below 100mm or above 300mm VL53L4CD_SetDistanceThreshold(dev,100,300,3): Above 100mm or below 300mm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(Dev_t)</td><td>dev : instance of selected <a class="el" href="classVL53L4CD.html">VL53L4CD</a> sensor. </td></tr>
    <tr><td class="paramname">(uint16_t)</td><td>distance_low_mm : Low distance threshold in millimeters. </td></tr>
    <tr><td class="paramname">(uint16_t)</td><td>distance_high_mm : High distance threshold in millimeters. </td></tr>
    <tr><td class="paramname">(uint8_t)</td><td>window : Interrupt windows (0=below low threshold; 1=above high threshold; 2=out of low/high windows; 3=in low/high windows) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(VL53L4CD_ERROR) status : 0 if OK. </dd></dl>

</div>
</div>
<a id="a87523f5f80914c5712bbb2d9714b6267" name="a87523f5f80914c5712bbb2d9714b6267"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87523f5f80914c5712bbb2d9714b6267">&#9670;&nbsp;</a></span>VL53L4CD_SetI2CAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VL53L4CD_Error VL53L4CD_API::VL53L4CD_SetI2CAddress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVL53L4CD__LinuxDev.html">Dev_t</a>&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>new_address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets a new I2C address to a sensor. It can be used for example when multiple sensors share the same I2C bus. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(Dev_t)</td><td>dev : Device instance to update. </td></tr>
    <tr><td class="paramname">(uint8_t)</td><td>new_address : New I2C address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(VL53L4CD_ERROR) status : 0 if I2C address has been correctly programmed. </dd></dl>

</div>
</div>
<a id="a4cd4dc976d343d0cff8696ea60a1068d" name="a4cd4dc976d343d0cff8696ea60a1068d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cd4dc976d343d0cff8696ea60a1068d">&#9670;&nbsp;</a></span>VL53L4CD_SetOffset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VL53L4CD_Error VL53L4CD_API::VL53L4CD_SetOffset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVL53L4CD__LinuxDev.html">Dev_t</a>&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>OffsetValueInMm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets a new offset correction in mm. Offset corresponds to the difference in millimeters between real distance and measured distance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(Dev_t)</td><td>dev : instance of selected <a class="el" href="classVL53L4CD.html">VL53L4CD</a> sensor. </td></tr>
    <tr><td class="paramname">(int16_t)</td><td>OffsetValueInMm : Offset value in millimeters. The minimum value is -1024mm and maximum is 1023mm. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(uint8_t) status : 0 if OK. </dd></dl>

</div>
</div>
<a id="a2585a3f22fdf2b0ee32820ec42da3961" name="a2585a3f22fdf2b0ee32820ec42da3961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2585a3f22fdf2b0ee32820ec42da3961">&#9670;&nbsp;</a></span>VL53L4CD_SetRangeTiming()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VL53L4CD_Error VL53L4CD_API::VL53L4CD_SetRangeTiming </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVL53L4CD__LinuxDev.html">Dev_t</a>&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timing_budget_ms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>inter_measurement_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets new range timing. Timing are composed of TimingBudget and InterMeasurement. TimingBudget represents the timing during VCSEL enabled, and InterMeasurement the time between two measurements. The sensor can have different ranging mode depending of the configuration, please refer to the user manual for more information. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(Dev_t)</td><td>dev : instance of selected <a class="el" href="classVL53L4CD.html">VL53L4CD</a> sensor. </td></tr>
    <tr><td class="paramname">(uint32_t)</td><td>timing_budget_ms : New timing budget in ms. Value can be between 10ms and 200ms. Default is 50ms. </td></tr>
    <tr><td class="paramname">(uint32_t)</td><td>inter_measurement_ms : New inter-measurement in ms. If the value is equal to 0, the ranging period is defined by the timing budget. Otherwise, inter-measurement must be &gt; timing budget. When all the timing budget is consumed, the device goes in low power mode until inter-measurement is done. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(uint8_t) status : 0 if OK. </dd></dl>

</div>
</div>
<a id="ada4fb4ff20dacbed66e6c5261e4ff813" name="ada4fb4ff20dacbed66e6c5261e4ff813"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada4fb4ff20dacbed66e6c5261e4ff813">&#9670;&nbsp;</a></span>VL53L4CD_SetSigmaThreshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VL53L4CD_Error VL53L4CD_API::VL53L4CD_SetSigmaThreshold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVL53L4CD__LinuxDev.html">Dev_t</a>&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>sigma_mm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function programs a new sigma threshold. The sigma corresponds to the standard deviation of the returned pulse. If the computed sigma is above the programmed value, the result status in structure '<a class="el" href="structVL53L4CD__ResultsData__t.html" title="Packed reading results type.">VL53L4CD_ResultsData_t</a>' will be equal to 1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(Dev_t)</td><td>dev : instance of selected <a class="el" href="classVL53L4CD.html">VL53L4CD</a> sensor. </td></tr>
    <tr><td class="paramname">(uint16_t)</td><td>sigma_mm : New sigma threshold in mm. The default value is 15mm. Minimum is 0mm (not threshold), and maximum is 16383mm. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(VL53L4CD_ERROR) status : 0 if programming is or 255 if value is too high. </dd></dl>

</div>
</div>
<a id="a115c3de908fb7b9dbfcf91bdac6a551c" name="a115c3de908fb7b9dbfcf91bdac6a551c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a115c3de908fb7b9dbfcf91bdac6a551c">&#9670;&nbsp;</a></span>VL53L4CD_SetSignalThreshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VL53L4CD_Error VL53L4CD_API::VL53L4CD_SetSignalThreshold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVL53L4CD__LinuxDev.html">Dev_t</a>&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>signal_kcps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets a new signal threshold in kcps. If a target has a lower signal as the programmed value, the result status in structure '<a class="el" href="structVL53L4CD__ResultsData__t.html" title="Packed reading results type.">VL53L4CD_ResultsData_t</a>' will be equal to 2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(Dev_t)</td><td>dev : instance of selected <a class="el" href="classVL53L4CD.html">VL53L4CD</a> sensor. </td></tr>
    <tr><td class="paramname">(uint16_t)</td><td>signal_kcps : New signal threshold in kcps. The default value is 1024 kcps. Minimum is 0 kcps (no threshold), and maximum is 16384 kcps. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(VL53L4CD_ERROR) status : 0 if OK. </dd></dl>

</div>
</div>
<a id="a1e02c0ae9a798c8972e84cb22b3c4a06" name="a1e02c0ae9a798c8972e84cb22b3c4a06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e02c0ae9a798c8972e84cb22b3c4a06">&#9670;&nbsp;</a></span>VL53L4CD_SetXtalk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VL53L4CD_Error VL53L4CD_API::VL53L4CD_SetXtalk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVL53L4CD__LinuxDev.html">Dev_t</a>&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>XtalkValueKcps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets a new Xtalk value in kcps. Xtalk represents the correction to apply to the sensor when a protective coverglass is placed at the top of the sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(Dev_t)</td><td>dev : instance of selected <a class="el" href="classVL53L4CD.html">VL53L4CD</a> sensor. </td></tr>
    <tr><td class="paramname">(uint16_t)</td><td>XtalkValueKcps : New xtalk value in kcps. The default value is 0 kcps (no coverglass). Minimum is 0 kcps , and maximum is 128 kcps. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(VL53L4CD_ERROR) status : 0 if OK. </dd></dl>

</div>
</div>
<a id="a3013012a08e2592d13653a267806c98c" name="a3013012a08e2592d13653a267806c98c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3013012a08e2592d13653a267806c98c">&#9670;&nbsp;</a></span>VL53L4CD_StartRanging()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VL53L4CD_Error VL53L4CD_API::VL53L4CD_StartRanging </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVL53L4CD__LinuxDev.html">Dev_t</a>&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function starts a ranging session. The ranging operation is continuous. The clear interrupt has to be done after each get data to allow the interrupt to raise when the next data is ready. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(Dev_t)</td><td>dev : instance of selected <a class="el" href="classVL53L4CD.html">VL53L4CD</a> sensor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(VL53L4CD_ERROR) status : 0 if OK. </dd></dl>

</div>
</div>
<a id="aa9c83b64bcfbb37376b0694c64745564" name="aa9c83b64bcfbb37376b0694c64745564"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9c83b64bcfbb37376b0694c64745564">&#9670;&nbsp;</a></span>VL53L4CD_StartTemperatureUpdate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VL53L4CD_Error VL53L4CD_API::VL53L4CD_StartTemperatureUpdate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVL53L4CD__LinuxDev.html">Dev_t</a>&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function can be called when the temperature might have changed by more than 8 degrees Celsius. The function can only be used if the sensor is not ranging, otherwise, the ranging needs to be stopped using function '<a class="el" href="classVL53L4CD__API.html#a491af0b13c9fa2c9e3197b80c2f50f8b" title="This function stops the ranging in progress.">VL53L4CD_StopRanging()</a>'. After calling this function, the ranging can restart normally. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(Dev_t)</td><td>dev : instance of selected <a class="el" href="classVL53L4CD.html">VL53L4CD</a> sensor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(VL53L4CD_ERROR) status : 0 if update is OK. </dd></dl>

</div>
</div>
<a id="a491af0b13c9fa2c9e3197b80c2f50f8b" name="a491af0b13c9fa2c9e3197b80c2f50f8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a491af0b13c9fa2c9e3197b80c2f50f8b">&#9670;&nbsp;</a></span>VL53L4CD_StopRanging()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VL53L4CD_Error VL53L4CD_API::VL53L4CD_StopRanging </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVL53L4CD__LinuxDev.html">Dev_t</a>&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function stops the ranging in progress. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(Dev_t)</td><td>dev : instance of selected <a class="el" href="classVL53L4CD.html">VL53L4CD</a> sensor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(VL53L4CD_ERROR) status : 0 if OK. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/<a class="el" href="VL53L4CD__api_8h_source.html">VL53L4CD_api.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Apr 16 2024 08:17:01 for btb by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
